<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Farmers' Market Interactive Map</title>
    <!-- Preconnect to external resources for faster loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="dns-prefetch" href="https://basemaps.cartocdn.com">
    <!-- Font loading with display swap for faster text rendering -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <style>
        :root {
            --fm-parking-color: #F0B535; --fm-restroom-color: #D35400; --fm-seating-color: #A51D40;
            --poi-default-color: #6c757d; --marker-border-color: #FFEE99; --popup-border-color: #E0E0E0;
            --palette-light-base: #EDEDE6; --vendor-parking-color: #795548; 
            --public-parking-fill-color: #F0B535; --vendor-parking-fill-color: #A1887F; 
            --market-tokens-color: #FFD700; 
        }
        body { margin: 0; padding: 0; font-family: 'Poppins', sans-serif; overflow: hidden; height: 100vh; contain: layout style paint; }
        #map { height: 100%; width: 100%; background-color: var(--palette-light-base); contain: layout style paint; }
        #map-loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.85); z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 1.1em; color: #333; transition: opacity 0.3s ease-out;
        }
        #map-message {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75); color: white; padding: 10px 15px;
            border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1001; text-align: center; font-size: 0.9em; max-width: 90%; 
            display: none; 
        }
        /* Your existing custom icon and popup styles remain here... */
        .custom-base-icon { display: flex; align-items: center; justify-content: center; border-radius: 50%; text-align: center; box-sizing: border-box; transition: width 0.2s ease-in-out, height 0.2s ease-in-out, opacity 0.2s ease-in-out, transform 0.2s ease-in-out, border-radius 0.2s ease-in-out; border: 1px solid rgba(0,0,0,0.1); position: relative; }
        .custom-base-icon i { line-height: inherit !important; transition: font-size 0.2s ease-in-out; }
        .vendor-marker-fa, .poi-marker-fa { border: 2px solid var(--marker-border-color); box-shadow: 0 2px 5px rgba(0,0,0,0.3); background-color: var(--marker-bg-color, #696969); }
        .poi-marker-char { font-weight: bold; color: white; box-shadow: 0 0 3px rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.5); }
        
        /* Mobile-optimized touch targets */
        @media (max-width: 768px) {
            .custom-base-icon { min-width: 44px; min-height: 44px; }
            .leaflet-popup-content-wrapper { max-width: 90vw !important; }
            .custom-popup .popup-button { padding: 12px 16px; font-size: 1em; }
        }
        
        /* Find My Location Button */
        .locate-btn {
            position: absolute; bottom: 20px; right: 10px; z-index: 1000;
            width: 48px; height: 48px; border-radius: 50%;
            background: white; border: 2px solid rgba(0,0,0,0.2);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease;
        }
        .locate-btn:hover { background: #f0f0f0; transform: scale(1.05); }
        .locate-btn:active { transform: scale(0.95); }
        .locate-btn i { font-size: 20px; color: #333; }
        .locate-btn.locating i { animation: pulse 1s infinite; color: #2196F3; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        /* User location marker */
        .user-location-marker {
            width: 20px; height: 20px; background: #2196F3;
            border: 3px solid white; border-radius: 50%;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
        }
        .user-location-accuracy {
            background: rgba(33, 150, 243, 0.15);
            border: 1px solid rgba(33, 150, 243, 0.3);
        }
        .multi-stall-pill-icon { box-shadow: 0 1px 3px rgba(0,0,0,0.25); border: 1px solid var(--marker-border-color); overflow: hidden; display: flex; align-items: center; justify-content: center; color: white; }
        .multi-stall-pill-icon .fa-solid { text-shadow: 0 0 2px black; }
        .highlighted-map-feature { z-index: 1000 !important; }
        .highlighted-map-feature::after { content: ''; position: absolute; left: 50%; top: 50%; width: 140%; height: 140%; transform: translate(-50%, -50%); background-image: radial-gradient(ellipse at center, rgba(255,215,0,0.75) 0%, rgba(255,215,0,0.6) 30%, rgba(255,223,0,0.3) 60%, rgba(255,223,0,0) 75%); border-radius: 50%; z-index: -1; pointer-events: none; transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out; }
        .multi-stall-pill-icon.highlighted-map-feature::after { width: 115%; height: 125%; border-radius: inherit; }
        .custom-popup .leaflet-popup-content-wrapper { background: #fff; color: #333; border-radius: 8px; box-shadow: 0 3px 14px rgba(0,0,0,0.4); padding: 0; min-width: 280px; max-width: 360px; width: auto; }
        .custom-popup .leaflet-popup-content { margin: 0; line-height: 1.5; font-size: 14px; padding: 1px; word-break: break-word; }
        .custom-popup .leaflet-popup-tip-container { width: 40px; height: 20px; }
        .custom-popup .leaflet-popup-tip { background: #fff; border: none; box-shadow: none; width: 20px; height: 20px; padding:0; margin: -10px auto 0; transform: rotate(45deg) scale(0.8); border-bottom: 1px solid var(--popup-border-color); border-right: 1px solid var(--popup-border-color); }
        .custom-popup .popup-header { padding: 12px 15px 10px; border-bottom: 1px solid var(--popup-border-color); }
        .custom-popup .popup-title { font-size: 1.2em; font-weight: 600; margin: 0 0 5px 0; color: #333; }
        .custom-popup .popup-category-badge { font-size: 0.8em; padding: 3px 8px; border-radius: 12px; display: inline-block; margin-bottom: 5px; }
        .custom-popup .popup-stall-id { font-size: 0.9em; color: #555; margin: 0; }
        .custom-popup .popup-body { padding: 10px 15px; }
        .custom-popup .popup-description { margin: 0 0 10px 0; font-size: 0.95em; overflow-wrap: break-word; white-space: pre-wrap; max-height: 150px; overflow-y: auto; }
        .custom-popup .popup-tags { margin-top: 5px; }
        .custom-popup .popup-tags .popup-tag { background-color: #e9ecef; color: #495057; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-right: 5px; margin-bottom: 5px; display: inline-block; }
        .custom-popup .popup-footer { padding: 10px 15px; border-top: 1px solid var(--popup-border-color); display: flex; justify-content: flex-start; gap: 10px; }
        .custom-popup .popup-button { background-color: #5cb85c; color: white; padding: 8px 12px; border-radius: 5px; text-decoration: none; font-size: 0.9em; transition: background-color 0.2s; display: inline-flex; align-items: center; }
        .custom-popup .popup-button:hover { background-color: #4cae4c; }
        .custom-popup .popup-button i { margin-left: 5px; }
        .custom-popup a.leaflet-popup-close-button { color: #777 !important; top: 12px; right: 12px; font-size: 1.2em; }
        .custom-popup a.leaflet-popup-close-button:hover { color: #333 !important; }
        .hidden-icon { display: none !important; }
       .parking-area-polygon { stroke: true; weight: 1.5; opacity: 0.8; fillOpacity: 0.15; }
       .public-parking-area { fill: var(--public-parking-fill-color); color: var(--public-parking-fill-color); }
       .vendor-parking-area { fill: var(--vendor-parking-fill-color); color: var(--vendor-parking-fill-color); }
       .seating-area-polygon { fill: var(--fm-seating-color); color: var(--fm-seating-color); }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="map-loader"><i class="fa-solid fa-spinner fa-spin fa-2x" style="margin-bottom: 15px;"></i>Loading map data...</div>
    <div id="map-message"></div>
    <button id="locate-btn" class="locate-btn" title="Find my location" aria-label="Find my location">
        <i class="fa-solid fa-location-crosshairs"></i>
    </button>

    <script>
        const VENDOR_TYPE_MARKER_BG_COLORS = {"Grower/Producer/Processor": "#00965F", "On-site Prepared Food Vendor": "#C76832", "Crafter/Artisan": "#4169E1", "Occasional Vendor": "#7B68EE", "N/A": "#696969", "Default": "#696969"};
        const DEFAULT_ICON_FG_COLOR = "#FFFFFF";
        const PARKING_COLOR = 'var(--fm-parking-color)'; const RESTROOM_COLOR = 'var(--fm-restroom-color)'; const SEATING_COLOR = 'var(--fm-seating-color)'; const POI_DEFAULT_COLOR = 'var(--poi-default-color)'; const VENDOR_PARKING_COLOR = 'var(--vendor-parking-color)'; const MARKET_TOKENS_COLOR = 'var(--market-tokens-color)';
        const VENDOR_ICON_CONFIG = { keywords: [ { keywords: ["photo"], faClass: 'fa-camera'}, { keywords: ["garden"], faClass: 'fa-seedling'}, { keywords: ["breakfast", "egg"], faClass: 'fa-egg'}, { keywords: ["bread"], faClass: 'fa-bread-slice'}, { keywords: ["pie"], faClass: 'fa-chart-pie'}, { keywords: ["cookie"], faClass: 'fa-cookie-bite'}, { keywords: ["cake", "bakery"], faClass: 'fa-cake-candles'}, { keywords: ["coffee"], faClass: 'fa-mug-saucer'}, { keywords: ["tea"], faClass: 'fa-leaf'}, { keywords: ["juice"], faClass: 'fa-martini-glass-citrus'}, { keywords: ["wine"], faClass: 'fa-wine-glass'}, { keywords: ["beer"], faClass: 'fa-beer-mug-empty'}, { keywords: ["kombucha"], faClass: 'fa-bottle-droplet'}, { keywords: ["cheese"], faClass: 'fa-cheese'}, { keywords: ["dairy"], faClass: 'fa-cow'}, { keywords: ["beef"], faClass: 'fa-cow'}, { keywords: ["pork", "bacon"], faClass: 'fa-bacon'}, { keywords: ["poultry"], faClass: 'fa-drumstick-bite'}, { keywords: ["meat"], faClass: 'fa-drumstick-bite'}, { keywords: ["seafood"], faClass: 'fa-fish-fins'}, { keywords: ["taco", "mexican"], faClass: 'fa-pepper-hot'}, { keywords: ["pizza"], faClass: 'fa-pizza-slice'}, { keywords: ["sandwich"], faClass: 'fa-burger'}, { keywords: ["crepe", "crêpe"], faClass: 'fa-stroopwafel'}, { keywords: ["ice cream", "popsicle"], faClass: 'fa-ice-cream'}, { keywords: ["popcorn"], faClass: 'fa-bowl-food'}, { keywords: ["apple"], faClass: 'fa-apple-whole'}, { keywords: ["corn"], faClass: 'fa-candy-cane'}, { keywords: ["tomato"], faClass: 'fa-lemon'}, { keywords: ["berry"], faClass: 'fa-apple-whole'}, { keywords: ["pepper"], faClass: 'fa-pepper-hot'}, { keywords: ["lettuce", "greens"], faClass: 'fa-leaf'}, { keywords: ["pumpkin", "squash"], faClass: 'fa-seedling'}, { keywords: ["onion", "garlic"], faClass: 'fa-stroopwafel'}, { keywords: ["potato"], faClass: 'fa-cubes-stacked'}, { keywords: ["mushroom", "fungi"], faClass: 'fa-fan'}, { keywords: ["beans", "peas"], faClass: 'fa-seedling'}, { keywords: ["carrot"], faClass: 'fa-carrot'}, { keywords: ["fruit"], faClass: 'fa-apple-whole'}, { keywords: ["vegetable", "produce"], faClass: 'fa-carrot'}, { keywords: ["flower"], faClass: 'fa-fan'}, { keywords: ["plant", "herbs"], faClass: 'fa-seedling'}, { keywords: ["honey", "beeswax"], faClass: 'fa-jar'}, { keywords: ["jam", "jelly", "syrup", "sauce", "salsa"], faClass: 'fa-jar-wheat'}, { keywords: ["soap", "candle", "lotion"], faClass: 'fa-soap'}, { keywords: ["jewelry"], faClass: 'fa-gem'}, { keywords: ["wood"], faClass: 'fa-tree'}, { keywords: ["pottery", "ceramic"], faClass: 'fa-paint-roller'}, { keywords: ["textile", "fabric"], faClass: 'fa-shirt'}, { keywords: ["art", "painting"], faClass: 'fa-palette'}, { keywords: ["glass"], faClass: 'fa-gem'}, { keywords: ["leather"], faClass: 'fa-tag'}, { keywords: ["book"], faClass: 'fa-book-open-reader' }, { keywords: ["toy"], faClass: 'fa-dragon'}, { keywords: ["pet", "dog", "cat"], faClass: 'fa-paw'}, { keywords: ["crafter", "artisan"], faClass: 'fa-hands-asl-interpreting'}, { keywords: ["prepared food"], faClass: 'fa-utensils'}, { keywords: ["grower", "producer"], faClass: 'fa-tractor'}, { keywords: ["occasional"], faClass: 'fa-store-slash'} ], defaultVendor: { faClass: 'fa-store' } };

        let map;
        let vendorsOnDate = [], allStallLayouts = [], allPois = [];
        
        let stallIdToFeatureMap = new Map();
        let mainLayerGroup = L.featureGroup(), vendorMarkerRefs = {}, poiMarkerRefs = {};
        let vendorLayerGroup, poiLayerGroup;
        let parkingAreaLayerGroup = L.featureGroup();
        let baseStallLayerGroup = L.featureGroup();
        
        let selectedDate = "", currentHighlight = null, activeSearchTerm = "";
        let mapLoaderElement, mapMessageElement;
        let initialZoomDone = false;

        delete L.Icon.Default.prototype._getIconUrl;
        L.Icon.Default.mergeOptions({ iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png', iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png', shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png' });

        const MAX_ZOOM_VENDOR_FULL_SIZE = 19; const MIN_ZOOM_VENDOR_VISIBLE = 16;
        const VENDOR_BASE_SIZE = [36, 36]; const POI_ICON_SIZE = [30,30];
        const MULTI_STALL_PILL_HEIGHT = VENDOR_BASE_SIZE[1] * 0.60;
        const MULTI_STALL_MIN_PIXEL_WIDTH = VENDOR_BASE_SIZE[0] * 0.8;
        const HIGHLIGHT_SCALE_FACTOR = 1.2; const NORMAL_OPACITY = 1.0; const DEEMPHASIZED_OPACITY = 0.65;

        document.addEventListener('DOMContentLoaded', function() {
            mapLoaderElement = document.getElementById('map-loader');
            mapMessageElement = document.getElementById('map-message');
            initMap();
        });

        function initMap() {
            // Initialize map immediately for faster rendering (progressive enhancement)
            let lastView = null;
            try { const savedView = localStorage.getItem('farmersMarketMapView'); if (savedView) { lastView = JSON.parse(savedView); }}
            catch (e) { /* Silently handle localStorage errors */ }

            // preferCanvas: true optimizes mobile rendering performance
            map = L.map('map', { 
                preferCanvas: true,
                zoomControl: true,
                attributionControl: true,
                // Mobile-optimized settings
                tap: true,
                touchZoom: true,
                doubleClickZoom: true,
                boxZoom: false,
                keyboard: false,
                scrollWheelZoom: true,
                dragging: true
            }).setView( (lastView ? [lastView.lat, lastView.lng] : [42.5000, -90.6644]), (lastView ? lastView.zoom : 17) );
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '© OpenStreetMap contributors', subdomains: 'abcd', maxZoom: 20, minZoom: 13 }).addTo(map);
            
            vendorLayerGroup = L.layerGroup().addTo(map);
            poiLayerGroup = L.layerGroup().addTo(map);
            parkingAreaLayerGroup = L.layerGroup().addTo(map);
            baseStallLayerGroup = L.layerGroup().addTo(map);

            map.on('zoomend', handleZoomEnd);
            // Throttle localStorage writes to improve performance
            let saveViewTimeout = null;
            map.on('moveend zoomend', function() {
                if (map) {
                    clearTimeout(saveViewTimeout);
                    saveViewTimeout = setTimeout(() => {
                        const center = map.getCenter(); 
                        const zoom = map.getZoom();
                        try {
                            localStorage.setItem('farmersMarketMapView', JSON.stringify({ lat: center.lat, lng: center.lng, zoom: zoom }));
                        } catch(e) { /* Silently handle localStorage quota errors */ }
                    }, 500); // Throttle to once per 500ms
                }
            });

            // Setup "Find My Location" button (non-blocking, deferred for faster initial render)
            if (typeof requestIdleCallback !== 'undefined') {
                requestIdleCallback(() => setupGeolocation(), { timeout: 1000 });
            } else {
                setTimeout(setupGeolocation, 100);
            }

            // Signal to Velo that the map is ready to receive data
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({ type: "iframeReady", payload: { status: "htmlComponentLoaded" } }, "*");
            }
        }

        // Batch postMessage updates for better performance
        let pendingUpdates = null;
        let updateTimeout = null;
        
        function processPendingUpdates() {
            if (!pendingUpdates) return;
            
            const updates = pendingUpdates;
            pendingUpdates = null;
            updateTimeout = null;
            
            let needsReRender = false;
            let needsStyleUpdate = false;
            
            // Process updates in order
            updates.forEach(update => {
                const { type, payload } = update;
                
                switch (type) { 
                    case "loadMapData":
                        if (payload) {
                            vendorsOnDate = payload.vendorsOnDate || [];
                            allStallLayouts = payload.allStallLayouts || [];
                            allPois = payload.allPois || [];
                            selectedDate = payload.currentDate || "";
                            currentHighlight = null; 
                            activeSearchTerm = "";   
                            needsReRender = true;
                        }
                        break;
                    case "mapLoading":
                        if (mapLoaderElement) mapLoaderElement.style.display = 'flex';
                        break;
                    case "mapDataError":
                        if (mapMessageElement && payload && payload.message) {
                            mapMessageElement.textContent = "Error loading map data: " + payload.message;
                            mapMessageElement.style.display = 'block';
                        }
                        if (mapLoaderElement) mapLoaderElement.style.display = 'none';
                        break;
                    case "setHighlight": 
                        if (payload) { 
                            currentHighlight = { type: payload.type, id: payload.id, criteria: payload.criteria }; 
                            activeSearchTerm = ""; 
                            needsStyleUpdate = true; 
                        } 
                        break;
                    case "clearHighlight": 
                        currentHighlight = null; 
                        activeSearchTerm = ""; 
                        needsStyleUpdate = true; 
                        break;
                    case "searchText": 
                        if (payload) { 
                            const newSearchTerm = payload.term ? payload.term.trim() : ""; 
                            if (newSearchTerm !== activeSearchTerm) { 
                                activeSearchTerm = newSearchTerm; 
                                currentHighlight = null; 
                                needsStyleUpdate = true; 
                            } 
                        } 
                        break;
                }
            });
            
            // Execute render/update once for all batched updates
            if (needsReRender) { 
                renderAllFeatures(); 
            } else if (needsStyleUpdate) { 
                updateExistingMarkerStyles(); 
            }
            
            // Handle fly-to for filter/search actions
            const lastUpdate = updates[updates.length - 1];
            if (lastUpdate && (lastUpdate.type === "setHighlight" || lastUpdate.type === "searchText" || lastUpdate.type === "clearHighlight")) {
                setTimeout(findAndFlyToTarget, 150); 
            }
        }
        
        window.addEventListener("message", (event) => {
            if (event.data && event.data.type) {
                // Batch updates that can be combined (style updates, not data loads)
                const canBatch = event.data.type !== "loadMapData" && event.data.type !== "mapLoading" && event.data.type !== "mapDataError";
                
                if (canBatch && pendingUpdates) {
                    // Replace previous style updates with latest (deduplicate)
                    pendingUpdates = pendingUpdates.filter(u => 
                        u.type !== event.data.type || 
                        (event.data.type === "setHighlight" && u.payload?.id !== event.data.payload?.id)
                    );
                    pendingUpdates.push({ type: event.data.type, payload: event.data.payload });
                    
                    // Reset timeout for batching window
                    clearTimeout(updateTimeout);
                    updateTimeout = setTimeout(processPendingUpdates, 16); // ~1 frame at 60fps
                } else {
                    // Process any pending batched updates first
                    if (pendingUpdates) {
                        clearTimeout(updateTimeout);
                        processPendingUpdates();
                    }
                    
                    // Critical updates (loadMapData, mapLoading, mapDataError) process immediately
                    // Style updates start a new batch
                    if (canBatch) {
                        pendingUpdates = [{ type: event.data.type, payload: event.data.payload }];
                        updateTimeout = setTimeout(processPendingUpdates, 16);
                    } else {
                        // Process critical update immediately
                        pendingUpdates = [{ type: event.data.type, payload: event.data.payload }];
                        processPendingUpdates();
                    }
                }
            }
        });

        function renderAllFeatures() {
            if (!map || !allStallLayouts) return;

            // Clear all layers before re-rendering
            mainLayerGroup.clearLayers(); 
            parkingAreaLayerGroup.clearLayers(); 
            baseStallLayerGroup.clearLayers();
            vendorMarkerRefs = {}; 
            poiMarkerRefs = {};
            let allDrawnFeaturesForBounds = [];

            // 1. Populate stallIdToFeatureMap and draw base stall outlines
            stallIdToFeatureMap.clear();
            (allStallLayouts || []).forEach(stallItem => {
                try {
                    // Velo now sends the stall title already cleaned/standardized
                    const stallKey = stallItem.title; 
                    if (stallKey && stallItem.geoJsonFeature) {
                        const feature = JSON.parse(stallItem.geoJsonFeature);
                        stallIdToFeatureMap.set(stallKey, feature);
                        const layer = L.geoJSON(feature, { style: { fillColor: "#CCCCCC", weight: 1, opacity: 0.5, color: 'grey', fillOpacity: 0.2 }, interactive: false }).addTo(baseStallLayerGroup);
                        allDrawnFeaturesForBounds.push(layer);
                    }
                } catch(e) { /* Silently handle parsing errors */ }
            });

            // 2. Render POIs (both polygons and points)
            (allPois || []).forEach(poiItem => {
                try {
                    const feature = JSON.parse(poiItem.geoJsonFeature);
                    if (!feature.properties) feature.properties = {};
                    feature.properties.poiType = poiItem.poiType; // Ensure poiType from Wix is in the feature
                    feature.properties.description = poiItem.description;
                    feature.properties.title = poiItem.title;

                    const isMatch = itemMatchesHighlight(null, 'poi', feature.properties);
                    const isDimmed = (currentHighlight || activeSearchTerm) && !isMatch;
                    
                    const poiLayer = L.geoJSON(feature, {
                        pointToLayer: (feat, latlng) => L.marker(latlng, { icon: createDynamicPoiIcon(feat.properties, false, isDimmed) }),
                        style: (feat) => {
                            let styleClass = '';
                            const poiTypeLower = (feat.properties.poiType || "").toLowerCase();
                            if (poiTypeLower.includes("publicparking")) styleClass = 'public-parking-area';
                            else if (poiTypeLower.includes("vendorparking")) styleClass = 'vendor-parking-area';
                            else if (poiTypeLower.includes("seating")) styleClass = 'seating-area-polygon';
                            return { className: `parking-area-polygon ${styleClass}`, interactive: !!feat.properties.description, fillOpacity: isDimmed ? DEEMPHASIZED_OPACITY * 0.5 : 0.15, opacity: isDimmed ? DEEMPHASIZED_OPACITY : 0.8 };
                        },
                        onEachFeature: (feat, layer) => {
                            let popupContent = `<b>${feat.properties.title || 'Point of Interest'}</b>`;
                            if (feat.properties.description) popupContent += `<br>${feat.properties.description}`;
                            if (feat.properties.poiType) popupContent += `<br><i>(${feat.properties.poiType})</i>`;
                            layer.bindPopup(popupContent, { className: 'custom-popup' });
                            poiMarkerRefs[feat.properties.title] = {marker: layer, feature: feat};
                        }
                    }).addTo(parkingAreaLayerGroup);
                    allDrawnFeaturesForBounds.push(poiLayer);
                } catch(e) { /* Silently handle POI rendering errors */ }
            });

            // 3. Render vendor markers
            (vendorsOnDate || []).forEach(vendorFullDetails => {
                if (!vendorFullDetails.StallList || vendorFullDetails.StallList.length === 0) return;
                
                const contiguousStallBlocks = groupContiguousStalls(vendorFullDetails.StallList);
                contiguousStallBlocks.forEach(stallBlock => {
                    const blockFeatures = stallBlock.map(sID => stallIdToFeatureMap.get(sID)).filter(f => f && f.geometry); 
                    if (blockFeatures.length === 0) return; // Skip invalid stall blocks
                    
                    const isMatch = itemMatchesHighlight(vendorFullDetails, 'vendor', blockFeatures[0].properties);
                    const isDimmed = (currentHighlight || activeSearchTerm) && !isMatch;
                    
                    let icon, marker, latlng;
                    if (blockFeatures.length > 1) { 
                        const blockCoords = blockFeatures.map(f => L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]));
                        const bounds = L.latLngBounds(blockCoords);
                        latlng = bounds.getCenter(); 
                        icon = createMultiStallPillIcon(vendorFullDetails, blockFeatures, false, isDimmed);
                    } else { 
                        latlng = L.latLng(blockFeatures[0].geometry.coordinates[1], blockFeatures[0].geometry.coordinates[0]);
                        icon = createDynamicVendorIcon(vendorFullDetails, false, isDimmed);
                    }
                    
                    marker = L.marker(latlng, { icon, alt: vendorFullDetails.title, title: `${vendorFullDetails.title} (Stalls: ${stallBlock.join(', ')})`, zIndexOffset: isDimmed ? 0 : 100 });
                    
                    let popupContent = `<div class="popup-header"><h3 class="popup-title">${vendorFullDetails.title}</h3><span class="popup-category-badge" style="background-color:${VENDOR_TYPE_MARKER_BG_COLORS[vendorFullDetails.vendorType] || '#696969'}; color:#fff;"><i class="fa-solid ${determineVendorFaClass(vendorFullDetails)}" style="margin-right: 4px;"></i> ${vendorFullDetails.vendorType || 'N/A'}</span><p class="popup-stall-id">Stalls: <strong>${stallBlock.join(', ')}</strong></p></div>`;
                    if (vendorFullDetails.description) popupContent += `<div class="popup-body"><p class="popup-description">${vendorFullDetails.description}</p></div>`;
                    if (vendorFullDetails.arraystring) { 
                        const tagsHtml = vendorFullDetails.arraystring.split(/[,;]/).map(tag => tag.trim()).filter(tag => tag).map(tag => `<span class="popup-tag">${tag}</span>`).join(''); 
                        if (tagsHtml) popupContent += `<div class="popup-body" style="padding-top:0px;"><div class="popup-tags">${tagsHtml}</div></div>`;
                    }
                    
                    let footerContent = ""; 
                    if (vendorFullDetails.url) { footerContent += `<a href="${vendorFullDetails.url.startsWith('http') ? vendorFullDetails.url : 'https://' + vendorFullDetails.url}" target="_blank" class="popup-button">Website <i class="fa-solid fa-arrow-up-right-from-square"></i></a>`;}
                    const directionsTargetName = encodeURIComponent(`${vendorFullDetails.title} at Dubuque Farmers Market`);
                    const directionsUrl = `http://maps.google.com/?q=${latlng.lat},${latlng.lng}&query=${directionsTargetName}`;
                    footerContent += `<a href="${directionsUrl}" target="_blank" class="popup-button">Directions <i class="fa-solid fa-diamond-turn-right"></i></a>`;
                    if (footerContent) popupContent += `<div class="popup-footer">${footerContent}</div>`;
                    
                    marker.bindPopup(popupContent, { className: 'custom-popup', minWidth: 280 });
                    marker.on('click', e => map.flyTo(e.latlng, Math.max(map.getZoom(), 18)));
                    marker.addTo(vendorLayerGroup);
                    
                    vendorMarkerRefs[vendorFullDetails.title] = {marker: marker, data: vendorFullDetails, feature: blockFeatures[0], stallBlock: stallBlock}; 
                });
            });
            
            // 4. Set map view and display messages
            if (!initialZoomDone && allDrawnFeaturesForBounds.length > 0) {
                 const boundsGroup = L.featureGroup(allDrawnFeaturesForBounds);
                 if (boundsGroup.getLayers().length > 0) { map.fitBounds(boundsGroup.getBounds().pad(0.1)); initialZoomDone = true; }
            }
            
            const mapMessageEl = document.getElementById('map-message');
            if (vendorsOnDate.length > 0) {
                mapMessageEl.style.display = 'none';
            } else if (selectedDate) {
                 mapMessageEl.textContent = `No vendors scheduled for ${new Date(selectedDate + "T00:00:00Z").toLocaleDateString('en-US', {timeZone:'UTC'})}.`;
                 mapMessageEl.style.display = 'block';
            } else {
                 mapMessageEl.textContent = 'Select a date to see vendor locations.';
                 mapMessageEl.style.display = 'block';
            }
            
            if (mapLoaderElement) mapLoaderElement.style.display = 'none';
        }
        
        // ==================== GEOLOCATION ====================
        
        let userLocationMarker = null;
        let userAccuracyCircle = null;

        function setupGeolocation() {
            const locateBtn = document.getElementById('locate-btn');
            if (!locateBtn) return;

            // Hide button if geolocation not supported
            if (!navigator.geolocation) {
                locateBtn.style.display = 'none';
                return;
            }

            locateBtn.addEventListener('click', () => {
                locateBtn.classList.add('locating');
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        locateBtn.classList.remove('locating');
                        const { latitude, longitude, accuracy } = position.coords;
                        const userLatLng = L.latLng(latitude, longitude);

                        // Remove existing markers
                        if (userLocationMarker) map.removeLayer(userLocationMarker);
                        if (userAccuracyCircle) map.removeLayer(userAccuracyCircle);

                        // Add accuracy circle
                        userAccuracyCircle = L.circle(userLatLng, {
                            radius: accuracy,
                            className: 'user-location-accuracy',
                            interactive: false
                        }).addTo(map);

                        // Add user location marker
                        userLocationMarker = L.marker(userLatLng, {
                            icon: L.divIcon({
                                className: 'user-location-marker',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            }),
                            zIndexOffset: 1000
                        }).addTo(map);

                        userLocationMarker.bindPopup('<b>You are here</b><br>Accuracy: ~' + Math.round(accuracy) + 'm');

                        // Fly to user location
                        map.flyTo(userLatLng, Math.max(map.getZoom(), 18), { duration: 0.8 });
                    },
                    (error) => {
                        locateBtn.classList.remove('locating');
                        let errorMsg = 'Unable to get your location.';
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                errorMsg = 'Location access denied. Please enable location permissions.';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMsg = 'Location unavailable. Please try again.';
                                break;
                            case error.TIMEOUT:
                                errorMsg = 'Location request timed out. Please try again.';
                                break;
                        }
                        if (mapMessageElement) {
                            mapMessageElement.textContent = errorMsg;
                            mapMessageElement.style.display = 'block';
                            setTimeout(() => { mapMessageElement.style.display = 'none'; }, 4000);
                        }
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 60000
                    }
                );
            });
        }

        // ==================== HELPER FUNCTIONS ====================

        // Determines if a vendor/POI matches the current highlight or search criteria
        function itemMatchesHighlight(vendorData, itemType, featureProps) {
            // If no active filter, everything matches
            if (!currentHighlight && !activeSearchTerm) return true;

            // Handle text search
            if (activeSearchTerm) {
                const searchLower = activeSearchTerm.toLowerCase();
                if (itemType === 'vendor' && vendorData) {
                    const searchableText = [
                        vendorData.title || '',
                        vendorData.description || '',
                        vendorData.vendorType || '',
                        vendorData.arraystring || ''
                    ].join(' ').toLowerCase();
                    return searchableText.includes(searchLower);
                }
                if (itemType === 'poi' && featureProps) {
                    const searchableText = [
                        featureProps.title || '',
                        featureProps.description || '',
                        featureProps.poiType || ''
                    ].join(' ').toLowerCase();
                    return searchableText.includes(searchLower);
                }
                return false;
            }

            // Handle highlight criteria
            if (currentHighlight) {
                const { type: highlightType, id: highlightValue } = currentHighlight;

                if (itemType === 'vendor' && vendorData) {
                    if (highlightType === 'vendorType') {
                        return vendorData.vendorType === highlightValue;
                    }
                    if (highlightType === 'keyword') {
                        const keywords = highlightValue.toLowerCase().split(' ');
                        const vendorText = [
                            vendorData.title || '',
                            vendorData.description || '',
                            vendorData.arraystring || ''
                        ].join(' ').toLowerCase();
                        return keywords.some(kw => vendorText.includes(kw));
                    }
                    if (highlightType === 'vendorId') {
                        return vendorData._id === highlightValue;
                    }
                }

                if (itemType === 'poi' && featureProps) {
                    if (highlightType === 'poiType') {
                        const poiTypeLower = (featureProps.poiType || '').toLowerCase();
                        const highlightLower = highlightValue.toLowerCase();
                        return poiTypeLower.includes(highlightLower) || highlightLower.includes(poiTypeLower);
                    }
                }
                return false;
            }
            return true;
        }

        // Determines the FontAwesome class based on vendor name/description keywords
        function determineVendorFaClass(vendorData) {
            if (!vendorData) return VENDOR_ICON_CONFIG.defaultVendor.faClass;
            const textToSearch = [
                vendorData.title || '',
                vendorData.description || '',
                vendorData.arraystring || ''
            ].join(' ').toLowerCase();

            for (const config of VENDOR_ICON_CONFIG.keywords) {
                if (config.keywords.some(kw => textToSearch.includes(kw.toLowerCase()))) {
                    return config.faClass;
                }
            }
            return VENDOR_ICON_CONFIG.defaultVendor.faClass;
        }

        // Creates a dynamic icon for single-stall vendors
        function createDynamicVendorIcon(vendorData, isHighlighted = false, isDimmed = false) {
            const bgColor = VENDOR_TYPE_MARKER_BG_COLORS[vendorData.vendorType] || VENDOR_TYPE_MARKER_BG_COLORS["Default"];
            const faClass = determineVendorFaClass(vendorData);
            const currentZoom = map ? map.getZoom() : 17;
            
            let size = [...VENDOR_BASE_SIZE];
            let fontSize = 16;
            let opacity = NORMAL_OPACITY;

            // Scale based on zoom
            if (currentZoom < MIN_ZOOM_VENDOR_VISIBLE) {
                return L.divIcon({ className: 'hidden-icon', iconSize: [0, 0] });
            } else if (currentZoom < MAX_ZOOM_VENDOR_FULL_SIZE) {
                const scale = 0.6 + (currentZoom - MIN_ZOOM_VENDOR_VISIBLE) / (MAX_ZOOM_VENDOR_FULL_SIZE - MIN_ZOOM_VENDOR_VISIBLE) * 0.4;
                size = [VENDOR_BASE_SIZE[0] * scale, VENDOR_BASE_SIZE[1] * scale];
                fontSize = Math.max(10, 16 * scale);
            }

            if (isHighlighted) {
                size = [size[0] * HIGHLIGHT_SCALE_FACTOR, size[1] * HIGHLIGHT_SCALE_FACTOR];
                fontSize *= HIGHLIGHT_SCALE_FACTOR;
            }
            if (isDimmed) {
                opacity = DEEMPHASIZED_OPACITY;
            }

            const highlightClass = isHighlighted ? 'highlighted-map-feature' : '';

            const opacityStyle = isDimmed ? `opacity: ${opacity};` : '';

            return L.divIcon({
                className: `custom-base-icon vendor-marker-fa ${highlightClass}`,
                html: `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background-color:${bgColor};border-radius:50%;${opacityStyle}"><i class="fa-solid ${faClass}" style="font-size: ${fontSize}px; color: ${DEFAULT_ICON_FG_COLOR};"></i></div>`,
                iconSize: size,
                iconAnchor: [size[0] / 2, size[1] / 2],
                popupAnchor: [0, -size[1] / 2 - 5]
            });
        }

        // Creates a pill-shaped icon for vendors with multiple contiguous stalls
        function createMultiStallPillIcon(vendorData, blockFeatures, isHighlighted = false, isDimmed = false) {
            const bgColor = VENDOR_TYPE_MARKER_BG_COLORS[vendorData.vendorType] || VENDOR_TYPE_MARKER_BG_COLORS["Default"];
            const faClass = determineVendorFaClass(vendorData);
            const currentZoom = map ? map.getZoom() : 17;

            if (currentZoom < MIN_ZOOM_VENDOR_VISIBLE) {
                return L.divIcon({ className: 'hidden-icon', iconSize: [0, 0] });
            }

            let height = MULTI_STALL_PILL_HEIGHT;
            let width = Math.max(MULTI_STALL_MIN_PIXEL_WIDTH, blockFeatures.length * 20);
            let fontSize = 14;
            let opacity = NORMAL_OPACITY;

            // Scale based on zoom
            if (currentZoom < MAX_ZOOM_VENDOR_FULL_SIZE) {
                const scale = 0.6 + (currentZoom - MIN_ZOOM_VENDOR_VISIBLE) / (MAX_ZOOM_VENDOR_FULL_SIZE - MIN_ZOOM_VENDOR_VISIBLE) * 0.4;
                height *= scale;
                width *= scale;
                fontSize = Math.max(10, fontSize * scale);
            }

            if (isHighlighted) {
                height *= HIGHLIGHT_SCALE_FACTOR;
                width *= HIGHLIGHT_SCALE_FACTOR;
                fontSize *= HIGHLIGHT_SCALE_FACTOR;
            }
            if (isDimmed) {
                opacity = DEEMPHASIZED_OPACITY;
            }

            const highlightClass = isHighlighted ? 'highlighted-map-feature' : '';
            const opacityStyle = isDimmed ? `opacity: ${opacity};` : '';

            return L.divIcon({
                className: `custom-base-icon multi-stall-pill-icon ${highlightClass}`,
                html: `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background-color:${bgColor};border-radius:${height/2}px;${opacityStyle}"><i class="fa-solid ${faClass}" style="font-size: ${fontSize}px; color: ${DEFAULT_ICON_FG_COLOR};"></i></div>`,
                iconSize: [width, height],
                iconAnchor: [width / 2, height / 2],
                popupAnchor: [0, -height / 2 - 5]
            });
        }

        // Creates a dynamic icon for POIs (Points of Interest)
        function createDynamicPoiIcon(poiProps, isHighlighted = false, isDimmed = false) {
            const poiType = (poiProps.poiType || '').toLowerCase();
            let bgColor = POI_DEFAULT_COLOR;
            let faClass = 'fa-circle-info';
            let charIcon = null;

            // Determine icon and color based on POI type
            if (poiType.includes('parking')) {
                bgColor = poiType.includes('vendor') ? VENDOR_PARKING_COLOR : PARKING_COLOR;
                faClass = 'fa-square-parking';
            } else if (poiType.includes('restroom')) {
                bgColor = RESTROOM_COLOR;
                faClass = 'fa-restroom';
            } else if (poiType.includes('seating')) {
                bgColor = SEATING_COLOR;
                faClass = 'fa-chair';
            } else if (poiType.includes('information')) {
                bgColor = '#2196F3';
                faClass = 'fa-circle-info';
            } else if (poiType.includes('token')) {
                bgColor = MARKET_TOKENS_COLOR;
                faClass = 'fa-coins';
            } else if (poiType.includes('merch')) {
                bgColor = '#9C27B0';
                faClass = 'fa-shirt';
            } else if (poiType.includes('event')) {
                bgColor = '#E91E63';
                faClass = 'fa-calendar-star';
            }

            let size = [...POI_ICON_SIZE];
            let fontSize = 14;
            let opacity = NORMAL_OPACITY;

            if (isHighlighted) {
                size = [size[0] * HIGHLIGHT_SCALE_FACTOR, size[1] * HIGHLIGHT_SCALE_FACTOR];
                fontSize *= HIGHLIGHT_SCALE_FACTOR;
            }
            if (isDimmed) {
                opacity = DEEMPHASIZED_OPACITY;
            }

            const highlightClass = isHighlighted ? 'highlighted-map-feature' : '';
            const opacityStyle = isDimmed ? `opacity: ${opacity};` : '';

            return L.divIcon({
                className: `custom-base-icon poi-marker-fa ${highlightClass}`,
                html: `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background-color:${bgColor};border-radius:50%;${opacityStyle}"><i class="fa-solid ${faClass}" style="font-size: ${fontSize}px; color: ${DEFAULT_ICON_FG_COLOR};"></i></div>`,
                iconSize: size,
                iconAnchor: [size[0] / 2, size[1] / 2],
                popupAnchor: [0, -size[1] / 2 - 5]
            });
        }

        // Groups contiguous stall IDs together (e.g., [101, 102, 103] becomes one group)
        function groupContiguousStalls(stallList) {
            if (!stallList || stallList.length === 0) return [];
            if (stallList.length === 1) return [[stallList[0]]];

            // Sort stalls - handle alphanumeric (e.g., "A1", "101", "B2")
            const sorted = [...stallList].sort((a, b) => {
                const aMatch = a.match(/^([A-Za-z]*)(\d+)$/);
                const bMatch = b.match(/^([A-Za-z]*)(\d+)$/);
                
                if (aMatch && bMatch) {
                    // Both have letter prefix + number
                    if (aMatch[1] !== bMatch[1]) return aMatch[1].localeCompare(bMatch[1]);
                    return parseInt(aMatch[2]) - parseInt(bMatch[2]);
                }
                return a.localeCompare(b);
            });

            const groups = [];
            let currentGroup = [sorted[0]];

            for (let i = 1; i < sorted.length; i++) {
                const prev = sorted[i - 1];
                const curr = sorted[i];

                const prevMatch = prev.match(/^([A-Za-z]*)(\d+)$/);
                const currMatch = curr.match(/^([A-Za-z]*)(\d+)$/);

                // Check if contiguous (same prefix, numbers differ by 1)
                if (prevMatch && currMatch && 
                    prevMatch[1] === currMatch[1] && 
                    parseInt(currMatch[2]) - parseInt(prevMatch[2]) === 1) {
                    currentGroup.push(curr);
                } else {
                    groups.push(currentGroup);
                    currentGroup = [curr];
                }
            }
            groups.push(currentGroup);
            return groups;
        }

        // Updates existing marker styles without full re-render (for filter changes)
        function updateExistingMarkerStyles() {
            const currentZoom = map ? map.getZoom() : 17;

            // Update vendor markers
            Object.values(vendorMarkerRefs).forEach(({ marker, data, feature, stallBlock }) => {
                if (!marker || !data) return;

                const isMatch = itemMatchesHighlight(data, 'vendor', feature ? feature.properties : null);
                const isDimmed = (currentHighlight || activeSearchTerm) && !isMatch;
                const isHighlighted = isMatch && (currentHighlight || activeSearchTerm);

                let newIcon;
                if (stallBlock && stallBlock.length > 1) {
                    const blockFeatures = stallBlock.map(sID => stallIdToFeatureMap.get(sID)).filter(f => f);
                    newIcon = createMultiStallPillIcon(data, blockFeatures, isHighlighted, isDimmed);
                } else {
                    newIcon = createDynamicVendorIcon(data, isHighlighted, isDimmed);
                }

                marker.setIcon(newIcon);
                marker.setZIndexOffset(isDimmed ? 0 : (isHighlighted ? 200 : 100));
            });

            // Update POI markers (point-based only)
            Object.values(poiMarkerRefs).forEach(({ marker, feature }) => {
                if (!marker || !feature || !marker.setIcon) return; // Skip polygon POIs

                const isMatch = itemMatchesHighlight(null, 'poi', feature.properties);
                const isDimmed = (currentHighlight || activeSearchTerm) && !isMatch;
                const isHighlighted = isMatch && (currentHighlight || activeSearchTerm);

                const newIcon = createDynamicPoiIcon(feature.properties, isHighlighted, isDimmed);
                marker.setIcon(newIcon);
            });
        }

        // Handles zoom changes
        function handleZoomEnd() { 
            updateExistingMarkerStyles(); 
        }

        // Flies to the first matching highlighted target
        function findAndFlyToTarget() {
            if (!map) return;

            // Find first matching vendor
            for (const vendorTitle of Object.keys(vendorMarkerRefs)) {
                const ref = vendorMarkerRefs[vendorTitle];
                if (ref && ref.data && ref.marker) {
                    const isMatch = itemMatchesHighlight(ref.data, 'vendor', ref.feature ? ref.feature.properties : null);
                    if (isMatch && (currentHighlight || activeSearchTerm)) {
                        const latlng = ref.marker.getLatLng();
                        map.flyTo(latlng, Math.max(map.getZoom(), 18), { duration: 0.5 });
                        return;
                    }
                }
            }

            // Find first matching POI
            for (const poiTitle of Object.keys(poiMarkerRefs)) {
                const ref = poiMarkerRefs[poiTitle];
                if (ref && ref.feature) {
                    const isMatch = itemMatchesHighlight(null, 'poi', ref.feature.properties);
                    if (isMatch && (currentHighlight || activeSearchTerm)) {
                        if (ref.marker && ref.marker.getLatLng) {
                            map.flyTo(ref.marker.getLatLng(), Math.max(map.getZoom(), 18), { duration: 0.5 });
                        } else if (ref.marker && ref.marker.getBounds) {
                            map.flyToBounds(ref.marker.getBounds(), { padding: [50, 50], duration: 0.5 });
                        }
                        return;
                    }
                }
            }
        }
    </script>
</body>
</html>