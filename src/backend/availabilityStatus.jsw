import wixData from 'wix-data';

/**
 * Calculate availability status for all market dates
 * Returns availability counts for musicians, non-profits, and volunteers by role
 * @returns {Promise<Object>} Object with dateId as key and availability data as value
 */
export async function getDateAvailability() {
	try {
		console.log('üöÄ getDateAvailability() called');
		console.log('üìù Backend function runs with elevated permissions - should be able to read collections');
		
		// Get all assignments (we'll filter by status in code to handle case/whitespace issues)
		// Include both profileRef and dateRef to ensure we can access them
		// Note: Backend functions (.jsw) run with elevated permissions by default
		// Use limit(1000) to ensure we get all records (Wix default is 50)
		let allAssignments;
		try {
			allAssignments = await wixData.query('WeeklyAssignments')
				.include('profileRef')
				.include('dateRef')
				.limit(1000)
				.find();
			console.log(`üì¶ Query returned ${allAssignments.items.length} total assignments`);
			if (allAssignments.hasMore) {
				console.warn(`‚ö†Ô∏è WARNING: Query hasMore=true. Some assignments may be missing from availability calculation!`);
			}
		} catch (queryError) {
			console.error('‚ùå ERROR querying WeeklyAssignments:', queryError);
			console.error('This might indicate a permissions issue with the collection');
			throw queryError;
		}
		
		// Filter for approved assignments (case-insensitive, trim whitespace)
		const assignments = {
			items: allAssignments.items.filter(assignment => {
				const status = (assignment.applicationStatus || '').toString().trim();
				return status.toLowerCase() === 'approved';
			})
		};
		
		console.log(`üîç Found ${assignments.items.length} approved assignments out of ${allAssignments.items.length} total`);
		
		// Log status breakdown for debugging
		const statusBreakdown = {};
		allAssignments.items.forEach(a => {
			const status = (a.applicationStatus || 'null').toString().trim();
			statusBreakdown[status] = (statusBreakdown[status] || 0) + 1;
		});
		console.log('üìã Status breakdown:', statusBreakdown);
		
		// Initialize availability object
		const availability = {};
		
		// Process each assignment
		for (const assignment of assignments.items) {
			// Handle dateRef - when included, it's an object with _id property
			let dateId = null;
			if (assignment.dateRef) {
				if (typeof assignment.dateRef === 'object' && assignment.dateRef !== null) {
					// When included, dateRef is an object with _id
					dateId = assignment.dateRef._id || assignment.dateRef.id;
				} else if (typeof assignment.dateRef === 'string') {
					// When not included, dateRef might be just the ID string
					dateId = assignment.dateRef;
				}
			}
			
			const profile = assignment.profileRef;
			
			if (!dateId || !profile) {
				console.warn('‚ö†Ô∏è Skipping assignment - missing dateId or profile:', { 
					assignmentId: assignment._id,
					dateId: dateId, 
					dateRefType: typeof assignment.dateRef,
					dateRefValue: assignment.dateRef,
					dateRefId: assignment.dateRef?._id,
					hasProfile: !!profile,
					profileType: profile?.type
				});
				continue;
			}
			
			// Initialize date entry if needed
			if (!availability[dateId]) {
				availability[dateId] = {
					musicians: 0,
					musiciansByLocation: {
						'Location A': 0,  // 13th Street
						'Location B': 0,  // Food Court
						'Location C': 0   // 10th & Iowa St
					},
					nonProfits: 0,
					volunteers: {
						'Token Sales': 0,
						'Merch Sales': 0,
						'Setup': 0,
						'Teardown': 0,
						'Hospitality Support': 0,
						'No Preference': 0
					}
				};
			}
			
			// Count by type
			const type = profile.type;
			if (type === 'Musician') {
				availability[dateId].musicians++;
				// Track by location - only count if assignedMapId is set (confirmed location assignment)
				// assignedMapId is set when admin assigns location in admin dashboard
				const location = assignment.assignedMapId;
				if (location && availability[dateId].musiciansByLocation[location] !== undefined) {
					availability[dateId].musiciansByLocation[location]++;
				}
			} else if (type === 'NonProfit') {
				availability[dateId].nonProfits++;
				console.log(`‚úÖ Counted NonProfit for dateId: ${dateId}, count: ${availability[dateId].nonProfits}`);
			} else if (type === 'Volunteer') {
				const role = profile.volunteerRole || 'No Preference';
				if (availability[dateId].volunteers[role] !== undefined) {
					availability[dateId].volunteers[role]++;
				}
			}
		}
		
		// Debug logging
		console.log('üìä Availability summary:', {
			totalAssignmentsProcessed: assignments.items.length,
			totalDatesWithAvailability: Object.keys(availability).length,
			nonProfitDates: Object.keys(availability).filter(id => availability[id].nonProfits > 0).map(id => ({
				dateId: id,
				count: availability[id].nonProfits
			})),
			musicianDates: Object.keys(availability).filter(id => availability[id].musicians > 0).map(id => ({
				dateId: id,
				count: availability[id].musicians
			})),
			volunteerDates: Object.keys(availability).filter(id => {
				const vols = availability[id].volunteers;
				return Object.values(vols).some(count => count > 0);
			}).length
		});
		
		// If no availability data, log a warning
		if (Object.keys(availability).length === 0 && assignments.items.length > 0) {
			console.warn('‚ö†Ô∏è WARNING: Processed assignments but got empty availability object. Check dateRef handling.');
		}
		
		console.log('‚úÖ Returning availability object with', Object.keys(availability).length, 'dates');
		return availability;
	} catch (error) {
		console.error('‚ùå ERROR in getDateAvailability():', error);
		console.error('Error stack:', error.stack);
		console.error('Error details:', {
			message: error.message,
			name: error.name,
			toString: error.toString()
		});
		return {};
	}
}

/**
 * Get availability status for a specific date and type
 * @param {string} dateId - The date ID
 * @param {string} type - 'Musician', 'NonProfit', or 'Volunteer'
 * @param {string} volunteerRole - Optional volunteer role for volunteer-specific status
 * @returns {Promise<string>} Status: 'available', 'limited', or 'full'
 */
export async function getDateStatus(dateId, type, volunteerRole = null) {
	try {
		const availability = await getDateAvailability();
		const dateData = availability[dateId];
		
		if (!dateData) {
			return 'available'; // No data means available
		}
		
		if (type === 'Musician') {
			// 0-1 = available, 2 = limited, 3+ = full
			if (dateData.musicians >= 3) return 'full';
			if (dateData.musicians === 2) return 'limited';
			return 'available';
		} else if (type === 'NonProfit') {
			// 0 = available, 1+ = full (only one non-profit per week)
			return dateData.nonProfits >= 1 ? 'full' : 'available';
		} else if (type === 'Volunteer' && volunteerRole) {
			// Role-specific limits
			const roleLimits = {
				'Token Sales': 2,
				'Merch Sales': 2,
				'Setup': 2,
				'Teardown': 2,
				'Hospitality Support': 2,
				'No Preference': 1
			};
			
			const limit = roleLimits[volunteerRole] || 2;
			const count = dateData.volunteers[volunteerRole] || 0;
			
			if (count >= limit) return 'full';
			if (count >= Math.floor(limit * 0.7)) return 'limited';
			return 'available';
		}
		
		return 'available';
	} catch (error) {
		console.error('Error getting date status:', error);
		return 'available';
	}
}
