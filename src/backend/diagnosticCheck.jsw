import wixData from 'wix-data';

/**
 * DIAGNOSTIC FUNCTION - Check WeeklyAssignments data integrity
 * This will help us verify if approved assignments are actually in the database
 * and identify any data issues
 */
export async function checkAssignmentsStatus() {
	try {
		console.log('ðŸ” DIAGNOSTIC CHECK - Starting WeeklyAssignments analysis...');
		
		// Get ALL assignments WITHOUT include() first to see raw data
		const allAssignmentsRaw = await wixData.query('WeeklyAssignments')
			.find();
		
		console.log(`ðŸ“Š Total assignments in database (raw query): ${allAssignmentsRaw.items.length}`);
		
		// Now get with includes
		const allAssignments = await wixData.query('WeeklyAssignments')
			.include('profileRef')
			.include('dateRef')
			.find();
		
		console.log(`ðŸ“Š Total assignments with includes: ${allAssignments.items.length}`);
		
		// Analyze by status
		const statusBreakdown = {};
		const approvedAssignments = [];
		const dataIssues = [];
		const missingNames = [];
		
		// Look specifically for "She Unites" and "Natalie Finley"
		let sheUnitesFound = false;
		let natalieFinleyFound = false;
		
		allAssignmentsRaw.items.forEach(assignment => {
			// Get status (handle various formats)
			const rawStatus = assignment.applicationStatus;
			const normalizedStatus = (rawStatus || 'null').toString().trim();
			
			// Count by status
			statusBreakdown[normalizedStatus] = (statusBreakdown[normalizedStatus] || 0) + 1;
			
			// Check for broken references in raw data
			const hasProfileRef = !!assignment.profileRef;
			const hasDateRef = !!assignment.dateRef;
			
			if (!hasProfileRef) {
				dataIssues.push({
					id: assignment._id,
					issue: 'Missing profileRef',
					status: normalizedStatus,
					rawProfileRef: assignment.profileRef
				});
			}
			if (!hasDateRef) {
				dataIssues.push({
					id: assignment._id,
					issue: 'Missing dateRef', 
					status: normalizedStatus,
					rawDateRef: assignment.dateRef
				});
			}
			
			// Try to find She Unites and Natalie Finley by checking raw profileRef ID
			// We'll need to query SpecialtyProfiles separately to match names
		});
		
		// Now analyze the included data
		allAssignments.items.forEach(assignment => {
			const rawStatus = assignment.applicationStatus;
			const normalizedStatus = (rawStatus || 'null').toString().trim();
			
			// Get organization name from profile
			const orgName = assignment.profileRef?.organizationName || 
			                assignment.profileRef?.firstName + ' ' + assignment.profileRef?.lastName || 
			                'Unknown';
			
			// Check for specific names
			if (orgName.toLowerCase().includes('she unites')) {
				sheUnitesFound = true;
				console.log(`ðŸ” FOUND "She Unites": Status="${normalizedStatus}", ID=${assignment._id}`);
				console.log(`   Profile:`, assignment.profileRef);
				console.log(`   Date:`, assignment.dateRef);
			}
			if (orgName.toLowerCase().includes('natalie finley') || orgName.toLowerCase().includes('finley')) {
				natalieFinleyFound = true;
				console.log(`ðŸ” FOUND "Natalie Finley": Status="${normalizedStatus}", ID=${assignment._id}`);
				console.log(`   Profile:`, assignment.profileRef);
				console.log(`   Date:`, assignment.dateRef);
			}
			
			// Track approved assignments
			if (normalizedStatus.toLowerCase() === 'approved') {
				approvedAssignments.push({
					id: assignment._id,
					status: normalizedStatus,
					profileType: assignment.profileRef?.type || 'Unknown',
					organizationName: orgName,
					profileId: assignment.profileRef?._id || 'No profile ID',
					dateId: assignment.dateRef?._id || assignment.dateRef || 'Unknown',
					dateTitle: assignment.dateRef?.title || 'Unknown',
					createdDate: assignment._createdDate,
					updatedDate: assignment._updatedDate,
					hasProfileRef: !!assignment.profileRef,
					hasDateRef: !!assignment.dateRef
				});
			}
			
			// Check if profileRef resolved properly
			if (assignment.profileRef === null || assignment.profileRef === undefined) {
				missingNames.push({
					id: assignment._id,
					status: normalizedStatus,
					issue: 'profileRef is null after include()',
					rawProfileRef: allAssignmentsRaw.items.find(a => a._id === assignment._id)?.profileRef
				});
			}
		});
		
		console.log('\nðŸ“‹ STATUS BREAKDOWN:');
		console.log(JSON.stringify(statusBreakdown, null, 2));
		
		console.log(`\nðŸ” SPECIFIC SEARCH RESULTS:`);
		console.log(`  She Unites found: ${sheUnitesFound ? 'YES âœ…' : 'NO âŒ'}`);
		console.log(`  Natalie Finley found: ${natalieFinleyFound ? 'YES âœ…' : 'NO âŒ'}`);
		
		console.log(`\nâœ… APPROVED ASSIGNMENTS: ${approvedAssignments.length}`);
		if (approvedAssignments.length > 0) {
			console.log('Approved assignments details:');
			approvedAssignments.forEach(a => {
				console.log(`  - ${a.profileType}: ${a.organizationName} (Date: ${a.dateTitle})`);
				console.log(`    Assignment ID: ${a.id}`);
				console.log(`    Profile ID: ${a.profileId}`);
				console.log(`    Date ID: ${a.dateId}`);
				console.log(`    Status: "${a.status}"`);
				console.log(`    Has Profile: ${a.hasProfileRef}, Has Date: ${a.hasDateRef}`);
				console.log('');
			});
		} else {
			console.warn('âš ï¸ WARNING: NO APPROVED ASSIGNMENTS FOUND IN DATABASE');
		}
		
		if (dataIssues.length > 0) {
			console.log(`\nâš ï¸ DATA INTEGRITY ISSUES (broken references): ${dataIssues.length}`);
			dataIssues.forEach(issue => {
				console.log(`  - ${issue.issue} (Assignment ID: ${issue.id}, Status: ${issue.status})`);
				console.log(`    Raw value:`, issue.rawProfileRef || issue.rawDateRef);
			});
		}
		
		if (missingNames.length > 0) {
			console.log(`\nâš ï¸ UNRESOLVED REFERENCES (include() failed): ${missingNames.length}`);
			missingNames.forEach(issue => {
				console.log(`  - ${issue.issue} (Assignment ID: ${issue.id}, Status: ${issue.status})`);
				console.log(`    Raw profileRef from DB:`, issue.rawProfileRef);
			});
		}
		
		// Return summary
		return {
			success: true,
			totalAssignments: allAssignments.items.length,
			statusBreakdown,
			approvedCount: approvedAssignments.length,
			approvedAssignments,
			dataIssues,
			missingNames,
			sheUnitesFound,
			natalieFinleyFound,
			message: approvedAssignments.length > 0 
				? `Found ${approvedAssignments.length} approved assignments in database. They should be visible when Status filter is set to "Approved" or "All Statuses".`
				: 'WARNING: No approved assignments found. This indicates potential data loss or status field corruption.'
		};
		
	} catch (error) {
		console.error('âŒ ERROR in diagnostic check:', error);
		console.error('Error details:', error.message, error.stack);
		return {
			success: false,
			error: error.message,
			stack: error.stack
		};
	}
}

/**
 * Check specific date availability status
 * Useful for debugging why dates show as "available" when they should be reserved
 */
export async function checkDateAvailability(dateId) {
	try {
		console.log(`ðŸ” Checking availability for date ID: ${dateId}`);
		
		// Get all assignments for this date
		const assignments = await wixData.query('WeeklyAssignments')
			.eq('dateRef', dateId)
			.include('profileRef')
			.include('dateRef')
			.find();
		
		console.log(`Found ${assignments.items.length} total assignments for this date`);
		
		// Filter for approved only
		const approved = assignments.items.filter(a => {
			const status = (a.applicationStatus || '').toString().trim().toLowerCase();
			return status === 'approved';
		});
		
		console.log(`Found ${approved.items.length} APPROVED assignments for this date`);
		
		// Breakdown by type
		const breakdown = {
			Musician: 0,
			NonProfit: 0,
			Volunteer: 0
		};
		
		approved.forEach(a => {
			const type = a.profileRef?.type;
			if (breakdown[type] !== undefined) {
				breakdown[type]++;
			}
		});
		
		console.log('Approved assignments by type:', breakdown);
		
		return {
			dateId,
			totalAssignments: assignments.items.length,
			approvedAssignments: approved.length,
			breakdown,
			details: approved.map(a => ({
				id: a._id,
				type: a.profileRef?.type,
				name: a.profileRef?.organizationName,
				status: a.applicationStatus
			}))
		};
		
	} catch (error) {
		console.error('Error checking date availability:', error);
		return { error: error.message };
	}
}
